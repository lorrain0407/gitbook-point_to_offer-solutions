{"./":{"url":"./","title":"Introduction","keywords":"","body":"gitbook-point_to_offer-solutions GitBook for Point to Offer solutions. Demo: https://liulin1.gitbooks.io/gitbook-point_to_offer-solutions/content/ GitHub: https://github.com/lorrain0407/gitbook-point_to_offer-solutions Setup $ npm install gitbook-cli -g $ git clone $ cd gitbook-point_to_offer-solutions $ gitbook serve "},"solutions/Link Summary.html":{"url":"solutions/Link Summary.html","title":"1 链表基础知识","keywords":"","body":"1 链表基础知识 和数组一样是一种线性结构，但存储空间是临时分配的，通过指针查找。 单链表，双链表；普通链表，循环链表。 插入删除：处理链表为空，链表长度为1的情况；注意头尾的处理。 单链表翻转， "},"solutions/printListFromTailToHead.html":{"url":"solutions/printListFromTailToHead.html","title":"1.1 从尾到头打印链表","keywords":"","body":"1.1 从尾到头打印链表 输入一个链表，从尾到头打印链表每个节点的值。 我的解法： struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } }; class Solution { public: vector printListFromTailToHead(ListNode* head) { vector res; if(head == NULL){ return res; } ListNode *t = head; while(t -> next != NULL){ res.push_back(t -> val); t = t -> next; } res.push_back(t -> val); reverse(res.begin(), res.end()); return res; } }; 用库函数，每次扫描一个节点，将该结点数据存入vector中，如果该节点有下一节点，将下一节点数据直接插入vector最前面。其实和我的解法类似了！ class Solution { public: vector printListFromTailToHead(struct ListNode* head) { vector value; if(head != NULL) { value.insert(value.begin(),head->val); while(head->next != NULL) { value.insert(value.begin(),head->next->val); head = head->next; } } return value; } }; 使用递归的解法，不过最好还是避免递归吧，毕竟慢啊！ class Solution { public: vector printListFromTailToHead(struct ListNode* head) { vector value; if(head != NULL) { value.insert(value.begin(),head->val); if(head->next != NULL) { vector tempVec = printListFromTailToHead(head->next); if(tempVec.size()>0) value.insert(value.begin(),tempVec.begin(),tempVec.end()); } } return value; } }; 利用栈的先进后出，emmmm。 class Solution { public: vector printListFromTailToHead(struct ListNode* head) { stack stack; vector vector; struct ListNode *p = head; if (head != NULL) { stack.push(p->val); while((p=p->next) != NULL) { stack.push(p->val); } while(!stack.empty()) { vector.push_back(stack.top()); stack.pop(); } } return vector; } }; 链表的就地反转（感觉还是蛮高级的），学习学习！ class Solution { public: vector printListFromTailToHead(ListNode* head) { vector s; if(head==NULL){ return s; } else if(head->next==NULL){ s.push_back(head->val); return s; } ListNode* now=head->next; ListNode* pre=head; ListNode* temp=head->next->next; while(now){ temp=now->next; now->next=pre; pre=now; now=temp; } head->next=NULL; while(pre){ s.push_back(pre->val); pre=pre->next; } return s; } }; "},"solutions/ReverseList.html":{"url":"solutions/ReverseList.html","title":"1.2 反转链表","keywords":"","body":"1.2 反转链表 输入一个链表，反转链表后，输出链表的所有元素。 怎么说呢，上个题，从尾到头输出链表，其实也可以通过反转后输出呢。我的解法如下： struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } }; class Solution { public: ListNode* ReverseList(ListNode* pHead) { if(pHead == NULL || pHead -> next == NULL){ return pHead; } ListNode* now = pHead -> next; ListNode* pre = pHead; while(now){ ListNode* temp = now -> next; now -> next = pre; pre = now; now = temp; } pHead -> next = NULL; return pre; } }; 上讨论区瞅瞅大家的解法。。。好像都大同小异，那就这样吧~ "},"solutions/Merge.html":{"url":"solutions/Merge.html","title":"1.3 合并两个排序的链表","keywords":"","body":"1.3 合并两个排序的链表 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 这应该是学数据结构链表时候最最基础的题了，做的很顺。但唯一要注意的是 ListNode* head = new ListNode(0); return head -> next; 否则会出错。 个人感觉前面的判断可有可无，在一个链表遍历完之后使用if直接指向剩余的或者用while一个一个填加都可以，但是用if感觉会好一些。解法如下： struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } }; class Solution { public: ListNode* Merge(ListNode* pHead1, ListNode* pHead2) { /*if(pHead1 == NULL && pHead2 == NULL){ return NULL; } if(pHead1 == NULL){ return pHead2; } if(pHead2 == NULL){ return pHead1; }*/ ListNode* head = new ListNode(0); ListNode* h = head; while(pHead1 && pHead2){ if(pHead1 -> val val){ h -> next = pHead1; pHead1 = pHead1 -> next; }else{ h -> next = pHead2; pHead2 = pHead2 -> next; } h = h -> next; } /*while(pHead1){ h -> next = pHead1; h = h -> next; pHead1 = pHead1 -> next; } while(pHead2){ h -> next = pHead2; h = h -> next; pHead2 = pHead2 -> next; }*/ if(pHead1){ h -> next = pHead1; } if(pHead2){ h -> next = pHead2; } return head -> next; } }; 还有使用递归的解法： class Solution { public: ListNode* Merge(ListNode* pHead1, ListNode* pHead2) { ListNode* node=NULL; if(pHead1==NULL){return node=pHead2;} if(pHead2==NULL){return node=pHead1;} if(pHead1->val>pHead2->val){ node=pHead2; node->next=Merge(pHead1,pHead2->next); }else { node=pHead1; node->next=Merge(pHead1->next,pHead2); } return node; } }; "},"solutions/FindKthToTail.html":{"url":"solutions/FindKthToTail.html","title":"1.4 链表中倒数第k个结点","keywords":"","body":"1.4 链表中倒数第k个结点 输入一个链表，输出该链表中倒数第k个结点。 怎么说呢，我能想到的方法感觉特别low，遍历一遍得到总数sum，然后从前到后找第sum - k + 1个 注意当k > sum时，返回的是NULL，这个不等价于返回ListNode* r = new ListNode(0); 而且这个题最后返回的也不是单纯的一个结点啊。 struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } }; class Solution { public: ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) { ListNode* h = pListHead; int sum = 0; while(h != NULL){ sum++; h = h -> next; } if(k > sum){ return NULL; } int n = sum - k; h = pListHead; while(n--){ h = h -> next; } return h; } }; 果然评论区有大神直接，膜拜一下~ 两个指针，先让第一个指针和第二个指针都指向头结点，然后再让第一个指针走(k-1)步，到达第k个节点。然后两个指针同时往后移动，当第一个结点到达末尾的时候，第二个结点所在位置就是倒数第k个节点了。。看时间复杂度的话好像没什么差，所以。。 class Solution { public: ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) { if(pListHead==NULL||k==0) return NULL; ListNode*pTail=pListHead,*pHead=pListHead; for(int i=1;inext!=NULL) pHead=pHead->next; else return NULL; } while(pHead->next!=NULL) { pHead=pHead->next; pTail=pTail->next; } return pTail; } }; 还有就是用vector、stack、递归的~感觉没必要啊~ "}}